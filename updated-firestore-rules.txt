rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Basic user profile rules with IP tracking support
    match /users/{userId} {
      // Allow read and write if the request is from the authenticated user that owns the document
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow authenticated users to read other users' documents for IP restriction checks
      // This is needed to count how many users share the same IP address
      allow read: if request.auth != null && 
                     resource.data.registrationIP != null;
      
      // WEBHOOK SUPPORT: Allow server-side updates for payment-related fields
      // This allows Stripe webhooks to update user plans without authentication
      allow update: if request.auth == null &&
                       // Only allow updates to payment/plan related fields
                       request.resource.data.diff(resource.data).affectedKeys()
                         .hasOnly(['planType', 'planStatus', 'planStartDate', 'planExpiryDate', 
                                  'stripeCustomerId', 'stripeSubscriptionId', 'lastUpdated', 'lastPlanUpdate']) &&
                       // Ensure planType is valid
                       (request.resource.data.planType in ['free', 'basic', 'premium']) &&
                       // Ensure planStatus is valid  
                       (request.resource.data.planStatus in ['active', 'cancelled', 'incomplete', 'past_due']);
      
      // Allow admin access (you can expand this with proper admin authentication later)
      // allow read, write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
      
      // Uploads subcollection rules
      match /uploads/{uploadId} {
        // Allow read and write if the request is from the authenticated user that owns the parent document
        allow read, write: if request.auth != null && request.auth.uid == userId;
        
        // Validate upload document structure
        allow create: if request.auth != null && 
                         request.auth.uid == userId && 
                         request.resource.data.keys().hasAll(['fileName', 'uploadDate', 'fileType', 'fileUrl', 'inputFields']) &&
                         request.resource.data.inputFields is number &&
                         (request.resource.data.inputFields <= getUserPlanLimit());
        
        // Function to get user's plan limits
        function getUserPlanLimit() {
          let userPlan = get(/databases/$(database)/documents/users/$(userId)).data.planType;
          return userPlan == 'free' ? 5 : 
                 userPlan == 'basic' ? 20 : 
                 userPlan == 'premium' ? 100 : 5; // Default to free plan limit
        }
      }
    }
    
    // IP tracking collection for storing IP-based restrictions
    match /ip_tracking/{ipAddress} {
      // Allow authenticated users to read and write IP tracking data
      allow read, write: if request.auth != null;
    }
    
    // WEBHOOK SUPPORT: Allow server-side transaction logging
    match /transactions/{transactionId} {
      // Allow webhooks to create transaction records
      allow create: if request.auth == null &&
                       request.resource.data.keys().hasAll(['userId', 'stripeInvoiceId', 'amount', 'currency', 'status']) &&
                       request.resource.data.status in ['succeeded', 'failed'];
      
      // Allow authenticated users to read their own transactions
      allow read: if request.auth != null && 
                     request.auth.uid == resource.data.userId;
    }
    
    // Other collection rules can be added here
    
    // Deny access to all other paths by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}